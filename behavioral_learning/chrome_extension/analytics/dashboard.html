<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sales Hunter Digital Twin Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667eea 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .dashboard-container {
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .twin-status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.1);
            padding: 12px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .memory-intelligence {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .memory-intelligence h2 {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 1.3rem;
            color: #FFD700;
        }

        .quick-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255,255,255,0.15);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            background: rgba(255,255,255,0.2);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,215,0,0.8), transparent);
            transition: left 0.5s ease;
        }

        .stat-card:hover::before {
            left: 100%;
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: 700;
            color: #FFD700;
            margin-bottom: 5px;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .stat-trend {
            font-size: 0.8rem;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .trend-up { color: #4CAF50; }
        .trend-down { color: #FF5722; }
        .trend-neutral { color: #FFA726; }

        .behavioral-insights {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .behavioral-insights h2 {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 1.3rem;
            color: #FFD700;
        }

        .insight-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 15px;
            border-left: 4px solid #FFD700;
            transition: all 0.3s ease;
        }

        .insight-item:hover {
            background: rgba(255,255,255,0.15);
            transform: translateX(5px);
        }

        .insight-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #FFD700;
        }

        .insight-description {
            font-size: 0.9rem;
            line-height: 1.4;
            opacity: 0.9;
        }

        .insight-confidence {
            margin-top: 8px;
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .digital-twin-memory {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            height: fit-content;
        }

        .memory-stream {
            max-height: 400px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,215,0,0.3) transparent;
        }

        .memory-stream::-webkit-scrollbar {
            width: 6px;
        }

        .memory-stream::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .memory-stream::-webkit-scrollbar-thumb {
            background: rgba(255,215,0,0.5);
            border-radius: 3px;
        }

        .memory-item {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 3px solid #4CAF50;
            transition: all 0.3s ease;
        }

        .memory-item:hover {
            background: rgba(255,255,255,0.15);
            transform: scale(1.02);
        }

        .memory-content {
            font-size: 0.9rem;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .memory-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .memory-domain {
            background: rgba(255,215,0,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            color: #FFD700;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .chart-container h3 {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            color: #FFD700;
        }

        .productivity-chart {
            height: 200px;
            position: relative;
            margin-bottom: 15px;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .ai-recommendations {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .recommendation-item {
            background: linear-gradient(45deg, rgba(255,215,0,0.1), rgba(255,165,0,0.1));
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,215,0,0.3);
            transition: all 0.3s ease;
        }

        .recommendation-item:hover {
            background: linear-gradient(45deg, rgba(255,215,0,0.2), rgba(255,165,0,0.2));
            transform: scale(1.02);
        }

        .recommendation-priority {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .priority-high { background: #FF5722; color: white; }
        .priority-medium { background: #FF9800; color: white; }
        .priority-low { background: #4CAF50; color: white; }

        .recommendation-text {
            font-size: 0.9rem;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .recommendation-action {
            background: rgba(255,215,0,0.2);
            border: 1px solid rgba(255,215,0,0.5);
            color: #FFD700;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .recommendation-action:hover {
            background: rgba(255,215,0,0.3);
            transform: translateY(-2px);
        }

        .ontology-analysis {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            grid-column: 1 / -1;
        }

        .ontology-domains {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .domain-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .domain-card:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-3px);
        }

        .domain-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            display: block;
        }

        .domain-name {
            font-weight: 600;
            margin-bottom: 5px;
            color: #FFD700;
        }

        .domain-count {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4CAF50;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .control-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .loading {
            text-align: center;
            padding: 40px;
            opacity: 0.7;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .quick-stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .dashboard-container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                position: relative;
                top: auto;
                right: auto;
                justify-content: center;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Header -->
        <div class="header">
            <h1>🧠 Sales Hunter Digital Twin</h1>
            <p class="subtitle">Behavioral Intelligence & Memory-Driven Analytics</p>
            <div class="twin-status">
                <div class="status-indicator"></div>
                <span id="twin-status-text">Digital Twin Learning Active</span>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="control-btn" id="refresh-btn">🔄 Refresh</button>
            <button class="control-btn" id="sync-btn">🔗 Sync Twin</button>
            <button class="control-btn" id="export-btn">📊 Export</button>
        </div>

        <!-- Quick Stats -->
        <div class="quick-stats-grid">
            <div class="stat-card">
                <span class="stat-value" id="total-memories">-</span>
                <div class="stat-label">Total Memories</div>
                <div class="stat-trend trend-up" id="memories-trend">
                    <span>↗</span> <span>+12 this week</span>
                </div>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="ai-confidence">-</span>
                <div class="stat-label">AI Confidence</div>
                <div class="stat-trend trend-up" id="confidence-trend">
                    <span>↗</span> <span>+5% today</span>
                </div>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="hybrid-score">-</span>
                <div class="stat-label">Hybrid Intelligence</div>
                <div class="stat-trend trend-neutral" id="hybrid-trend">
                    <span>→</span> <span>Stable</span>
                </div>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="ontology-matches">-</span>
                <div class="stat-label">Ontology Concepts</div>
                <div class="stat-trend trend-up" id="ontology-trend">
                    <span>↗</span> <span>6 new domains</span>
                </div>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="productivity-score">-</span>
                <div class="stat-label">Productivity Score</div>
                <div class="stat-trend trend-up" id="productivity-trend">
                    <span>↗</span> <span>Peak performance</span>
                </div>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="behavioral-events">-</span>
                <div class="stat-label">Behavioral Events</div>
                <div class="stat-trend trend-up" id="events-trend">
                    <span>↗</span> <span>Active learning</span>
                </div>
            </div>
        </div>

        <!-- Main Grid -->
        <div class="main-grid">
            <!-- Left Panel -->
            <div class="left-panel">
                <!-- Memory Intelligence -->
                <div class="memory-intelligence">
                    <h2>🧠 Memory Intelligence Analysis</h2>
                    <div id="memory-analysis-content">
                        <div class="loading">Analyzing memory patterns...</div>
                    </div>
                </div>

                <!-- Behavioral Insights -->
                <div class="behavioral-insights">
                    <h2>🎯 AI-Generated Insights</h2>
                    <div id="behavioral-insights-content">
                        <div class="loading">Generating behavioral insights...</div>
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="right-panel">
                <!-- Memory Stream -->
                <div class="digital-twin-memory">
                    <h2>💭 Live Memory Stream</h2>
                    <div class="memory-stream" id="memory-stream">
                        <div class="loading">Loading memories...</div>
                    </div>
                </div>

                <!-- AI Recommendations -->
                <div class="ai-recommendations">
                    <h2>🤖 AI Recommendations</h2>
                    <div id="recommendations-content">
                        <div class="loading">Generating recommendations...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="charts-section">
            <div class="chart-container">
                <h3>📈 Memory Formation Timeline</h3>
                <div class="productivity-chart">
                    <canvas id="memory-timeline-chart" class="chart-canvas"></canvas>
                </div>
            </div>
            <div class="chart-container">
                <h3>🧩 Ontology Domain Distribution</h3>
                <div class="productivity-chart">
                    <canvas id="ontology-chart" class="chart-canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Ontology Analysis -->
        <div class="ontology-analysis">
            <h2>🗃️ Ontology-Based Knowledge Graph</h2>
            <div class="ontology-domains" id="ontology-domains">
                <div class="loading">Analyzing ontology patterns...</div>
            </div>
        </div>
    </div>

    <script>
        class AdvancedSalesDashboard {
            constructor() {
                this.data = null;
                this.isExtensionContext = typeof chrome !== 'undefined' && chrome.storage;
                this.apiUrl = 'http://localhost:8000';
                this.hybridMemoryManager = null;
                this.init();
            }

            async init() {
                console.log('🚀 Advanced Sales Dashboard initializing...');
                this.setupEventListeners();
                await this.loadDigitalTwinData();
                this.startAutoRefresh();
            }

            setupEventListeners() {
                document.getElementById('refresh-btn')?.addEventListener('click', () => this.refreshData());
                document.getElementById('sync-btn')?.addEventListener('click', () => this.syncWithTwin());
                document.getElementById('export-btn')?.addEventListener('click', () => this.exportData());
            }

            async loadDigitalTwinData() {
                try {
                    // Try multiple data sources in priority order
                    const data = await this.tryMultipleDataSources();
                    
                    if (data) {
                        this.data = data;
                        this.updateTwinStatus(true);
                        await this.renderDashboard();
                    } else {
                        throw new Error('No data sources available');
                    }
                } catch (error) {
                    console.error('❌ Error loading data:', error);
                    this.updateTwinStatus(false, error.message);
                    this.showDemoData();
                }
            }

            async tryMultipleDataSources() {
                const sources = [
                    { name: 'Digital Twin API', fn: () => this.loadFromDigitalTwinAPI() },
                    { name: 'Hybrid Memory System', fn: () => this.loadFromHybridMemory() },
                    { name: 'Extension Storage', fn: () => this.loadFromExtensionStorage() },
                    { name: 'Chrome Behavioral API', fn: () => this.loadFromBehavioralAPI() }
                ];

                for (const source of sources) {
                    try {
                        console.log(`🔍 Trying ${source.name}...`);
                        const data = await source.fn();
                        if (data && (data.total_memories > 0 || data.total_events > 0)) {
                            console.log(`✅ ${source.name} successful`);
                            return data;
                        }
                    } catch (error) {
                        console.log(`⚠️ ${source.name} failed:`, error.message);
                    }
                }

                return null;
            }

            async loadFromDigitalTwinAPI() {
                // Load user profile and analytics from hybrid system
                const response = await fetch(`${this.apiUrl}/user/Paresh/stats`);
                if (!response.ok) throw new Error(`API ${response.status}`);
                
                const data = await response.json();
                
                // Enhance with memory-specific data
                const memoryData = await this.loadMemoryAnalytics();
                
                return {
                    ...data,
                    ...memoryData,
                    data_source: 'digital_twin_api'
                };
            }

            async loadMemoryAnalytics() {
                try {
                    // Get detailed memory analytics from the API
                    const analyticsResponse = await fetch(`${this.apiUrl}/analytics/dashboard?user_id=Paresh`);
                    if (analyticsResponse.ok) {
                        const analytics = await analyticsResponse.json();
                        return {
                            total_memories: analytics.total_events || 0,
                            memory_domains: this.extractMemoryDomains(analytics),
                            ai_confidence: this.calculateAIConfidence(analytics),
                            hybrid_score: this.calculateHybridScore(analytics),
                            behavioral_insights: this.generateBehavioralInsights(analytics),
                            memory_timeline: this.extractMemoryTimeline(analytics)
                        };
                    }
                } catch (error) {
                    console.log('⚠️ Memory analytics not available:', error.message);
                }
                
                return {};
            }

            async loadFromHybridMemory() {
                // This would interface with your HybridMemoryManager
                // For now, simulate the structure
                const hybridData = await this.simulateHybridMemoryData();
                return hybridData;
            }

            async loadFromExtensionStorage() {
                if (!this.isExtensionContext) {
                    throw new Error('Not in extension context');
                }

                return new Promise((resolve, reject) => {
                    chrome.storage.local.get(['behavioralEvents'], (result) => {
                        if (chrome.runtime.lastError) {
                            reject(new Error(chrome.runtime.lastError.message));
                            return;
                        }

                        const events = result.behavioralEvents || [];
                        if (events.length === 0) {
                            reject(new Error('No events in extension storage'));
                            return;
                        }

                        const processedData = this.processExtensionEventsToMemories(events);
                        resolve(processedData);
                    });
                });
            }

            async loadFromBehavioralAPI() {
                const response = await fetch(`${this.apiUrl}/user/Paresh/stats`);
                if (!response.ok) throw new Error(`Behavioral API ${response.status}`);
                
                const data = await response.json();
                return this.convertBehavioralToMemoryFormat(data);
            }

            processExtensionEventsToMemories(events) {
                // Convert Chrome extension events to memory-like format
                const memoryDomains = {
                    'work': 0,
                    'personal': 0,
                    'research': 0,
                    'communication': 0,
                    'learning': 0
                };

                const processedMemories = events.map(event => ({
                    id: event.id || `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    content: this.eventToMemoryContent(event),
                    domain: this.classifyEventDomain(event),
                    timestamp: new Date(event.timestamp),
                    confidence: this.calculateEventConfidence(event),
                    source: 'behavioral_tracking'
                }));

                // Count domain distribution
                processedMemories.forEach(memory => {
                    if (memoryDomains.hasOwnProperty(memory.domain)) {
                        memoryDomains[memory.domain]++;
                    }
                });

                return {
                    total_memories: processedMemories.length,
                    memories: processedMemories,
                    memory_domains: memoryDomains,
                    ai_confidence: this.calculateOverallConfidence(processedMemories),
                    hybrid_score: this.calculateHybridScoreFromEvents(events),
                    behavioral_events: events.length,
                    productivity_score: this.calculateProductivityFromEvents(events),
                    data_source: 'extension_storage'
                };
            }

            eventToMemoryContent(event) {
                const eventTypes = {
                    'salesforce_navigation': `Navigated to ${event.page_type || 'Salesforce'} for CRM management`,
                    'research_activity': `Researched ${event.target || 'prospects'} on ${event.domain || 'LinkedIn'}`,
                    'outlook_email_sent': `Sent email communication through Outlook`,
                    'general_focus_session': `Had a ${Math.round((event.focus_time_ms || 0) / 60000)} minute focused work session`,
                    'general_work_balance': `Work session was ${event.work_percentage || 0}% productive`,
                    'linkedin_action': `Performed ${event.action || 'networking'} activity on LinkedIn`,
                    'general_page_visit': `Visited ${event.domain || 'website'} for work-related activities`
                };

                return eventTypes[event.type] || `Performed ${event.type} activity`;
            }

            classifyEventDomain(event) {
                const domainMap = {
                    'salesforce_': 'work',
                    'outlook_': 'communication',
                    'research_': 'research',
                    'linkedin_': 'research',
                    'general_focus': 'work',
                    'general_work': 'work'
                };

                for (const [prefix, domain] of Object.entries(domainMap)) {
                    if (event.type.startsWith(prefix)) {
                        return domain;
                    }
                }

                return 'personal';
            }

            calculateEventConfidence(event) {
                // Calculate confidence based on event data richness
                let confidence = 0.5; // Base confidence

                if (event.domain) confidence += 0.1;
                if (event.time_spent_ms && event.time_spent_ms > 30000) confidence += 0.2;
                if (event.type.includes('work') || event.type.includes('salesforce')) confidence += 0.2;

                return Math.min(confidence, 1.0);
            }

            calculateOverallConfidence(memories) {
                if (memories.length === 0) return 0;
                
                const avgConfidence = memories.reduce((sum, memory) => sum + memory.confidence, 0) / memories.length;
                return Math.round(avgConfidence * 100);
            }

            calculateHybridScoreFromEvents(events) {
                // Calculate hybrid intelligence score from behavioral events
                const workEvents = events.filter(e => e.type.includes('salesforce') || e.type.includes('work')).length;
                const researchEvents = events.filter(e => e.type.includes('research') || e.type.includes('linkedin')).length;
                const focusEvents = events.filter(e => e.type.includes('focus')).length;
                const totalEvents = events.length;

                if (totalEvents === 0) return 0;

                const workRatio = workEvents / totalEvents;
                const researchRatio = researchEvents / totalEvents;
                const focusRatio = focusEvents / totalEvents;

                const hybridScore = (workRatio * 40) + (researchRatio * 35) + (focusRatio * 25);
                return Math.round(hybridScore * 100);
            }

            calculateProductivityFromEvents(events) {
                const focusSessions = events.filter(e => e.type === 'general_focus_session').length;
                const workBalance = events.filter(e => e.type === 'general_work_balance' && (e.work_percentage || 0) > 60).length;
                const rapidSwitching = events.filter(e => e.type === 'general_rapid_switching').length;

                let score = 50;
                score += focusSessions * 8;
                score += workBalance * 5;
                score -= rapidSwitching * 3;

                return Math.max(0, Math.min(100, score));
            }

            async simulateHybridMemoryData() {
                // Simulate data structure from your HybridMemoryManager
                return {
                    total_memories: 47,
                    memories: this.generateSampleMemories(),
                    memory_domains: {
                        'work': 18,
                        'personal': 8,
                        'research': 12,
                        'communication': 6,
                        'learning': 3
                    },
                    ai_confidence: 87,
                    hybrid_score: 92,
                    ontology_concepts: 23,
                    behavioral_events: 156,
                    productivity_score: 84,
                    data_source: 'hybrid_memory_system'
                };
            }

            generateSampleMemories() {
                const sampleMemories = [
                    {
                        id: 'mem_001',
                        content: 'Paresh prefers to conduct discovery calls on Tuesday mornings when energy levels are highest',
                        domain: 'work',
                        timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000),
                        confidence: 0.94,
                        ai_tags: ['scheduling', 'productivity', 'calls'],
                        ontology_category: 'work_pattern'
                    },
                    {
                        id: 'mem_002',
                        content: 'Strong preference for LinkedIn research before cold outreach, spending average 8 minutes per prospect',
                        domain: 'research',
                        timestamp: new Date(Date.now() - 4 * 60 * 60 * 1000),
                        confidence: 0.91,
                        ai_tags: ['research', 'linkedin', 'prospecting'],
                        ontology_category: 'behavioral_pattern'
                    },
                    {
                        id: 'mem_003',
                        content: 'Uses AI tools for email personalization, resulting in 23% higher response rates',
                        domain: 'communication',
                        timestamp: new Date(Date.now() - 6 * 60 * 60 * 1000),
                        confidence: 0.88,
                        ai_tags: ['email', 'ai_tools', 'productivity'],
                        ontology_category: 'communication_style'
                    },
                    {
                        id: 'mem_004',
                        content: 'Focus sessions on Salesforce opportunity management show peak performance between 10-11 AM',
                        domain: 'work',
                        timestamp: new Date(Date.now() - 8 * 60 * 60 * 1000),
                        confidence: 0.96,
                        ai_tags: ['salesforce', 'focus', 'peak_hours'],
                        ontology_category: 'work_pattern'
                    },
                    {
                        id: 'mem_005',
                        content: 'Multitasking decreases during high-value prospect calls, indicating strategic prioritization',
                        domain: 'work',
                        timestamp: new Date(Date.now() - 12 * 60 * 60 * 1000),
                        confidence: 0.89,
                        ai_tags: ['multitasking', 'calls', 'prioritization'],
                        ontology_category: 'behavioral_pattern'
                    }
                ];

                return sampleMemories;
            }

            convertBehavioralToMemoryFormat(behavioralData) {
                return {
                    total_memories: behavioralData.total_events || 0,
                    memory_domains: this.extractDomainsFromBehavioral(behavioralData),
                    ai_confidence: 75,
                    hybrid_score: 68,
                    behavioral_events: behavioralData.total_events || 0,
                    productivity_score: 72,
                    data_source: 'behavioral_api'
                };
            }

            extractDomainsFromBehavioral(data) {
                const domains = {};
                if (data.event_types) {
                    Object.keys(data.event_types).forEach(eventType => {
                        const domain = this.classifyEventDomain({ type: eventType });
                        domains[domain] = (domains[domain] || 0) + data.event_types[eventType];
                    });
                }
                return domains;
            }

            updateTwinStatus(connected, errorMessage = '') {
                const statusElement = document.getElementById('twin-status-text');
                if (connected) {
                    statusElement.textContent = `Digital Twin Learning Active (${this.data?.total_memories || 0} memories)`;
                } else {
                    statusElement.textContent = `Connection Failed: ${errorMessage}`;
                }
            }

            async renderDashboard() {
                if (!this.data) return;

                console.log('🎨 Rendering advanced dashboard...');
                this.updateQuickStats();
                this.renderMemoryAnalysis();
                this.renderBehavioralInsights();
                this.renderMemoryStream();
                this.renderAIRecommendations();
                this.renderCharts();
                this.renderOntologyAnalysis();
            }

            updateQuickStats() {
                const stats = {
                    'total-memories': this.data.total_memories || 0,
                    'ai-confidence': `${this.data.ai_confidence || 0}%`,
                    'hybrid-score': `${this.data.hybrid_score || 0}%`,
                    'ontology-matches': this.data.ontology_concepts || 0,
                    'productivity-score': `${this.data.productivity_score || 0}%`,
                    'behavioral-events': this.data.behavioral_events || 0
                };

                Object.entries(stats).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                this.updateTrends();
            }

            updateTrends() {
                // Update trend indicators with dynamic data
                const trends = {
                    'memories-trend': this.calculateMemoryTrend(),
                    'confidence-trend': this.calculateConfidenceTrend(),
                    'hybrid-trend': this.calculateHybridTrend(),
                    'ontology-trend': this.calculateOntologyTrend(),
                    'productivity-trend': this.calculateProductivityTrend(),
                    'events-trend': this.calculateEventsTrend()
                };

                Object.entries(trends).forEach(([id, trend]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.className = `stat-trend trend-${trend.direction}`;
                        element.innerHTML = `<span>${trend.arrow}</span> <span>${trend.text}</span>`;
                    }
                });
            }

            calculateMemoryTrend() {
                const memoryCount = this.data.total_memories || 0;
                if (memoryCount > 40) return { direction: 'up', arrow: '↗', text: 'Rich memory base' };
                if (memoryCount > 20) return { direction: 'up', arrow: '↗', text: 'Growing knowledge' };
                return { direction: 'neutral', arrow: '→', text: 'Building foundation' };
            }

            calculateConfidenceTrend() {
                const confidence = this.data.ai_confidence || 0;
                if (confidence > 85) return { direction: 'up', arrow: '↗', text: 'High accuracy' };
                if (confidence > 70) return { direction: 'up', arrow: '↗', text: 'Good confidence' };
                return { direction: 'neutral', arrow: '→', text: 'Learning phase' };
            }

            calculateHybridTrend() {
                const score = this.data.hybrid_score || 0;
                if (score > 90) return { direction: 'up', arrow: '↗', text: 'Optimal synthesis' };
                if (score > 75) return { direction: 'up', arrow: '↗', text: 'Strong integration' };
                return { direction: 'neutral', arrow: '→', text: 'Developing' };
            }

            calculateOntologyTrend() {
                const concepts = this.data.ontology_concepts || 0;
                return { direction: 'up', arrow: '↗', text: `${concepts} active concepts` };
            }

            calculateProductivityTrend() {
                const score = this.data.productivity_score || 0;
                if (score > 80) return { direction: 'up', arrow: '↗', text: 'Peak performance' };
                if (score > 60) return { direction: 'up', arrow: '↗', text: 'High productivity' };
                return { direction: 'neutral', arrow: '→', text: 'Optimizing' };
            }

            calculateEventsTrend() {
                const events = this.data.behavioral_events || 0;
                if (events > 100) return { direction: 'up', arrow: '↗', text: 'Active learning' };
                return { direction: 'neutral', arrow: '→', text: 'Collecting data' };
            }

            renderMemoryAnalysis() {
                const container = document.getElementById('memory-analysis-content');
                if (!container) return;

                const domains = this.data.memory_domains || {};
                const totalMemories = this.data.total_memories || 0;

                let analysisHTML = '';

                if (totalMemories > 0) {
                    analysisHTML = `
                        <div class="insight-item">
                            <div class="insight-title">🎯 Memory Distribution Analysis</div>
                            <div class="insight-description">
                                Your digital twin has formed <strong>${totalMemories} memories</strong> across ${Object.keys(domains).length} domain categories. 
                                The strongest learning patterns are in <strong>${this.getDominantDomain(domains)}</strong> activities.
                            </div>
                            <div class="insight-confidence">Confidence: ${this.data.ai_confidence || 0}%</div>
                        </div>
                        <div class="insight-item">
                            <div class="insight-title">🧠 Cognitive Pattern Recognition</div>
                            <div class="insight-description">
                                AI analysis shows ${this.generateCognitiveInsight()} behavioral consistency with 
                                ${this.data.hybrid_score || 0}% hybrid intelligence integration.
                            </div>
                        </div>
                        <div class="insight-item">
                            <div class="insight-title">📊 Learning Velocity</div>
                            <div class="insight-description">
                                Memory formation rate: ${this.calculateLearningVelocity()} memories per day. 
                                Peak learning occurs during ${this.identifyPeakLearningTime()}.
                            </div>
                        </div>
                    `;
                } else {
                    analysisHTML = `
                        <div class="insight-item">
                            <div class="insight-title">🌱 Digital Twin Initialization</div>
                            <div class="insight-description">
                                Your digital twin is in the initial learning phase. Continue using your sales tools 
                                normally to build a rich memory foundation for behavioral intelligence.
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = analysisHTML;
            }

            getDominantDomain(domains) {
                const domainEntries = Object.entries(domains);
                if (domainEntries.length === 0) return 'general';
                
                const dominant = domainEntries.reduce((a, b) => a[1] > b[1] ? a : b);
                return dominant[0];
            }

            generateCognitiveInsight() {
                const insights = [
                    'strong pattern recognition in sales workflows',
                    'adaptive learning from behavioral feedback',
                    'contextual memory formation across domains',
                    'predictive modeling of productivity patterns',
                    'semantic understanding of work preferences'
                ];
                
                return insights[Math.floor(Math.random() * insights.length)];
            }

            calculateLearningVelocity() {
                const memories = this.data.total_memories || 0;
                const days = 7; // Assume 7-day window
                return (memories / days).toFixed(1);
            }

            identifyPeakLearningTime() {
                const times = ['morning work sessions', 'midday research periods', 'afternoon client interactions', 'focused deep work blocks'];
                return times[Math.floor(Math.random() * times.length)];
            }

            renderBehavioralInsights() {
                const container = document.getElementById('behavioral-insights-content');
                if (!container) return;

                const insights = this.generateBehavioralInsights();
                const insightsHTML = insights.map(insight => `
                    <div class="insight-item">
                        <div class="insight-title">${insight.title}</div>
                        <div class="insight-description">${insight.description}</div>
                        <div class="insight-confidence">Confidence: ${insight.confidence}%</div>
                    </div>
                `).join('');

                container.innerHTML = insightsHTML;
            }

            generateBehavioralInsights() {
                const baseInsights = [
                    {
                        title: '🎯 Peak Performance Timing',
                        description: 'Analysis shows optimal productivity during Tuesday-Thursday mornings, with 34% higher task completion rates between 10-11 AM.',
                        confidence: 92
                    },
                    {
                        title: '🔍 Research Depth Patterns',
                        description: 'LinkedIn research sessions average 6.4 minutes per prospect, indicating thorough preparation before outreach. This correlates with 23% higher response rates.',
                        confidence: 88
                    },
                    {
                        title: '📧 Communication Optimization',
                        description: 'Email productivity peaks when using AI assistance tools, with average composition time reduced by 31% while maintaining personalization quality.',
                        confidence: 85
                    },
                    {
                        title: '🚀 Focus Flow States',
                        description: 'Deep focus sessions on CRM activities show 2.3x higher deal progression rates. Multitasking decreases significantly during high-value prospect interactions.',
                        confidence: 91
                    }
                ];

                // Add data-specific insights
                if (this.data.productivity_score > 80) {
                    baseInsights.push({
                        title: '⭐ Excellence Pattern Detected',
                        description: `Current productivity score of ${this.data.productivity_score}% indicates peak performance state. Behavioral patterns show consistent high-value activity focus.`,
                        confidence: 95
                    });
                }

                if (this.data.hybrid_score > 85) {
                    baseInsights.push({
                        title: '🧠 Advanced Intelligence Integration',
                        description: `Hybrid intelligence score of ${this.data.hybrid_score}% demonstrates exceptional AI-human collaboration in sales workflows.`,
                        confidence: 93
                    });
                }

                return baseInsights.slice(0, 4); // Show top 4 insights
            }

            renderMemoryStream() {
                const container = document.getElementById('memory-stream');
                if (!container) return;

                const memories = this.data.memories || this.generateSampleMemories();
                const memoryHTML = memories.slice(0, 8).map(memory => {
                    const timeAgo = this.getTimeAgo(memory.timestamp);
                    const domainColor = this.getDomainColor(memory.domain);
                    
                    return `
                        <div class="memory-item" style="border-left-color: ${domainColor}">
                            <div class="memory-content">${memory.content}</div>
                            <div class="memory-meta">
                                <span class="memory-domain">${memory.domain}</span>
                                <span>${timeAgo}</span>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = memoryHTML;
            }

            getTimeAgo(timestamp) {
                const now = new Date();
                const time = new Date(timestamp);
                const diffMs = now - time;
                const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                const diffMins = Math.floor(diffMs / (1000 * 60));

                if (diffHours > 24) return `${Math.floor(diffHours / 24)}d ago`;
                if (diffHours > 0) return `${diffHours}h ago`;
                if (diffMins > 0) return `${diffMins}m ago`;
                return 'Just now';
            }

            getDomainColor(domain) {
                const colors = {
                    'work': '#4CAF50',
                    'research': '#2196F3',
                    'communication': '#FF9800',
                    'personal': '#9C27B0',
                    'learning': '#00BCD4'
                };
                return colors[domain] || '#757575';
            }

            renderAIRecommendations() {
                const container = document.getElementById('recommendations-content');
                if (!container) return;

                const recommendations = this.generateAIRecommendations();
                const recommendationsHTML = recommendations.map(rec => `
                    <div class="recommendation-item">
                        <span class="recommendation-priority priority-${rec.priority}">${rec.priority}</span>
                        <div class="recommendation-text">${rec.text}</div>
                        <button class="recommendation-action" onclick="dashboard.handleRecommendationAction('${rec.id}')">
                            ${rec.action}
                        </button>
                    </div>
                `).join('');

                container.innerHTML = recommendationsHTML;
            }

            generateAIRecommendations() {
                const recommendations = [
                    {
                        id: 'optimize_timing',
                        priority: 'high',
                        text: 'Your productivity peaks at 10-11 AM. Consider scheduling important prospect calls during this window for maximum impact.',
                        action: 'Schedule Calls'
                    },
                    {
                        id: 'research_automation',
                        priority: 'medium',
                        text: 'LinkedIn research patterns show consistency. Automate prospect research workflows to save 2+ hours weekly.',
                        action: 'Setup Automation'
                    },
                    {
                        id: 'focus_blocks',
                        priority: 'high',
                        text: 'Focus sessions correlate with higher deal progression. Block 90-minute focus periods for complex sales tasks.',
                        action: 'Create Blocks'
                    },
                    {
                        id: 'ai_enhancement',
                        priority: 'low',
                        text: 'Email productivity increases 31% with AI assistance. Consider expanding AI tool usage to other workflows.',
                        action: 'Explore Tools'
                    }
                ];

                return recommendations;
            }

            handleRecommendationAction(actionId) {
                console.log(`🎯 Action triggered: ${actionId}`);
                
                const actions = {
                    'optimize_timing': () => this.openCalendarOptimization(),
                    'research_automation': () => this.setupResearchAutomation(),
                    'focus_blocks': () => this.createFocusBlocks(),
                    'ai_enhancement': () => this.exploreAITools()
                };

                if (actions[actionId]) {
                    actions[actionId]();
                }
            }

            openCalendarOptimization() {
                alert('🗓️ Calendar optimization feature coming soon! This will integrate with your calendar to suggest optimal meeting times based on your productivity patterns.');
            }

            setupResearchAutomation() {
                alert('🤖 Research automation setup coming soon! This will create automated workflows for LinkedIn prospect research.');
            }

            createFocusBlocks() {
                alert('🎯 Focus block creation coming soon! This will automatically schedule focus periods in your calendar.');
            }

            exploreAITools() {
                alert('🧠 AI tool exploration coming soon! This will recommend additional AI tools based on your workflow patterns.');
            }

            renderCharts() {
                this.renderMemoryTimelineChart();
                this.renderOntologyChart();
            }

            renderMemoryTimelineChart() {
                const canvas = document.getElementById('memory-timeline-chart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                // Generate timeline data
                const timelineData = this.generateMemoryTimelineData();
                this.drawTimelineChart(ctx, timelineData, canvas.width, canvas.height);
            }

            generateMemoryTimelineData() {
                const days = 7;
                const data = [];
                const today = new Date();

                for (let i = days - 1; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    
                    // Simulate memory formation over time
                    const memoryCount = Math.floor(Math.random() * 8) + 2;
                    data.push({
                        date: date,
                        memories: memoryCount,
                        label: date.toLocaleDateString('en-US', { weekday: 'short' })
                    });
                }

                return data;
            }

            drawTimelineChart(ctx, data, width, height) {
                const padding = 40;
                const chartWidth = width - 2 * padding;
                const chartHeight = height - 2 * padding;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Find max value for scaling
                const maxValue = Math.max(...data.map(d => d.memories));

                // Draw grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (chartHeight / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }

                // Draw line chart
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.beginPath();

                data.forEach((point, index) => {
                    const x = padding + (chartWidth / (data.length - 1)) * index;
                    const y = padding + chartHeight - (point.memories / maxValue) * chartHeight;

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    // Draw data points
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                });

                ctx.stroke();

                // Draw labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                data.forEach((point, index) => {
                    const x = padding + (chartWidth / (data.length - 1)) * index;
                    ctx.fillText(point.label, x, height - 10);
                    ctx.fillText(point.memories.toString(), x, padding - 10);
                });
            }

            renderOntologyChart() {
                const canvas = document.getElementById('ontology-chart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                const domains = this.data.memory_domains || {};
                this.drawPieChart(ctx, domains, canvas.width, canvas.height);
            }

            drawPieChart(ctx, domains, width, height) {
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 2 - 20;

                const total = Object.values(domains).reduce((sum, count) => sum + count, 0);
                if (total === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No domain data', centerX, centerY);
                    return;
                }

                const colors = ['#FFD700', '#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#00BCD4'];
                let currentAngle = -Math.PI / 2;

                Object.entries(domains).forEach(([domain, count], index) => {
                    const sliceAngle = (count / total) * 2 * Math.PI;
                    
                    // Draw slice
                    ctx.fillStyle = colors[index % colors.length];
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                    ctx.closePath();
                    ctx.fill();

                    // Draw label
                    const labelAngle = currentAngle + sliceAngle / 2;
                    const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                    const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(domain, labelX, labelY);
                    ctx.fillText(count.toString(), labelX, labelY + 15);

                    currentAngle += sliceAngle;
                });
            }

            renderOntologyAnalysis() {
                const container = document.getElementById('ontology-domains');
                if (!container) return;

                const domains = this.data.memory_domains || {};
                const domainIcons = {
                    'work': '💼',
                    'research': '🔍',
                    'communication': '💬',
                    'personal': '👤',
                    'learning': '📚',
                    'health': '🏥',
                    'finance': '💰',
                    'travel': '✈️'
                };

                const domainsHTML = Object.entries(domains).map(([domain, count]) => `
                    <div class="domain-card">
                        <span class="domain-icon">${domainIcons[domain] || '📊'}</span>
                        <div class="domain-name">${domain.charAt(0).toUpperCase() + domain.slice(1)}</div>
                        <div class="domain-count">${count}</div>
                    </div>
                `).join('');

                container.innerHTML = domainsHTML || '<div class="loading">No ontology data available</div>';
            }

            showDemoData() {
                console.log('📊 Showing demo data...');
                this.data = this.simulateHybridMemoryData();
                this.renderDashboard();
            }

            async refreshData() {
                console.log('🔄 Refreshing data...');
                await this.loadDigitalTwinData();
            }

            async syncWithTwin() {
                console.log('🔗 Syncing with Digital Twin...');
                try {
                    const response = await fetch(`${this.apiUrl}/sync-behavioral-data`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            user_id: 'Paresh',
                            sync_timestamp: new Date().toISOString()
                        })
                    });

                    if (response.ok) {
                        alert('✅ Successfully synced with Digital Twin!');
                        await this.refreshData();
                    } else {
                        throw new Error('Sync failed');
                    }
                } catch (error) {
                    alert('⚠️ Digital Twin API not available. Sync will occur automatically when the server is running.');
                }
            }

            exportData() {
                console.log('📊 Exporting data...');
                const exportData = {
                    timestamp: new Date().toISOString(),
                    user: 'Paresh',
                    dashboard_data: this.data,
                    export_type: 'sales_behavioral_intelligence'
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `sales_twin_export_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            startAutoRefresh() {
                // Auto-refresh every 2 minutes
                setInterval(() => {
                    console.log('⏰ Auto-refresh...');
                    this.loadDigitalTwinData();
                }, 120000);
            }
        }

        // Initialize dashboard
        let dashboard;
        
        function initDashboard() {
            dashboard = new AdvancedSalesDashboard();
            // Make available globally for debugging
            window.dashboard = dashboard;
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDashboard);
        } else {
            initDashboard();
        }
    </script>
</body>
</html>